//! Compiled native code representation
//!
//! Contains executable code generated by JIT compilers along with
//! metadata for OSR and deoptimization.

use crate::ir::IRFunction;
use crate::osr::OSREntry;
use bytecode_system::BytecodeChunk;
use core_types::{JsError, Value};

/// Type of JIT compilation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompilationTier {
    /// Baseline template-based JIT
    Baseline,
    /// Optimizing speculative JIT
    Optimized,
}

/// Executable compiled code
///
/// Represents native code generated by the JIT compiler.
/// In this mock implementation, we store a closure that simulates
/// the native code behavior.
#[derive(Debug, Clone)]
pub struct CompiledCode {
    /// Pointer to the generated code (simulated)
    pub code: *const u8,
    /// Size of the generated code in bytes
    pub size: usize,
    /// Entry point for execution
    pub entry_point: *const (),
    /// OSR entry points for tier transitions
    pub osr_entries: Vec<OSREntry>,
    /// The original bytecode (for deoptimization)
    original_bytecode: BytecodeChunk,
    /// Compilation tier
    tier: CompilationTier,
    /// IR representation (for execution simulation)
    ir: IRFunction,
}

impl CompiledCode {
    /// Create new compiled code
    ///
    /// # Arguments
    /// * `bytecode` - Original bytecode chunk
    /// * `ir` - IR representation of the code
    /// * `tier` - Compilation tier (baseline or optimized)
    pub fn new(bytecode: BytecodeChunk, ir: IRFunction, tier: CompilationTier) -> Self {
        // In a real implementation, code would point to executable memory
        // Here we simulate it with a placeholder
        let code_placeholder: Vec<u8> = vec![0xCC; 64]; // INT3 placeholder
        let code_ptr = code_placeholder.as_ptr();
        let entry_point = code_ptr as *const ();

        // We intentionally leak the placeholder to keep the pointer valid
        // In a real implementation, this would be managed memory
        std::mem::forget(code_placeholder);

        Self {
            code: code_ptr,
            size: 64,
            entry_point,
            osr_entries: Vec::new(),
            original_bytecode: bytecode,
            tier,
            ir,
        }
    }

    /// Execute the compiled code
    ///
    /// This is a mock implementation that interprets the IR.
    /// In a real JIT, this would jump to native code.
    pub fn execute(&self) -> Result<Value, JsError> {
        let mut stack: Vec<Value> = Vec::new();

        for instruction in &self.ir.instructions {
            match &instruction.opcode {
                crate::ir::IROpcode::LoadConst(idx) => {
                    let bc_val = &self.ir.constants[*idx];
                    let val = match bc_val {
                        bytecode_system::Value::Number(n) => {
                            if n.fract() == 0.0 && *n >= i32::MIN as f64 && *n <= i32::MAX as f64 {
                                Value::Smi(*n as i32)
                            } else {
                                Value::Double(*n)
                            }
                        }
                        bytecode_system::Value::String(s) => {
                            // For simplicity, represent strings as Undefined in this mock
                            // A real implementation would allocate on heap
                            let _ = s;
                            Value::Undefined
                        }
                        bytecode_system::Value::Boolean(b) => Value::Boolean(*b),
                        bytecode_system::Value::Null => Value::Null,
                        bytecode_system::Value::Undefined => Value::Undefined,
                    };
                    stack.push(val);
                }
                crate::ir::IROpcode::LoadUndefined => {
                    stack.push(Value::Undefined);
                }
                crate::ir::IROpcode::LoadNull => {
                    stack.push(Value::Null);
                }
                crate::ir::IROpcode::LoadTrue => {
                    stack.push(Value::Boolean(true));
                }
                crate::ir::IROpcode::LoadFalse => {
                    stack.push(Value::Boolean(false));
                }
                crate::ir::IROpcode::Add(_type_hint) => {
                    if stack.len() >= 2 {
                        let b = stack.pop().unwrap();
                        let a = stack.pop().unwrap();
                        let result = match (a, b) {
                            (Value::Smi(x), Value::Smi(y)) => match x.checked_add(y) {
                                Some(sum) => Value::Smi(sum),
                                None => Value::Double(x as f64 + y as f64),
                            },
                            (Value::Double(x), Value::Double(y)) => Value::Double(x + y),
                            (Value::Smi(x), Value::Double(y)) => Value::Double(x as f64 + y),
                            (Value::Double(x), Value::Smi(y)) => Value::Double(x + y as f64),
                            _ => Value::Undefined,
                        };
                        stack.push(result);
                    }
                }
                crate::ir::IROpcode::Sub(_type_hint) => {
                    if stack.len() >= 2 {
                        let b = stack.pop().unwrap();
                        let a = stack.pop().unwrap();
                        let result = match (a, b) {
                            (Value::Smi(x), Value::Smi(y)) => match x.checked_sub(y) {
                                Some(diff) => Value::Smi(diff),
                                None => Value::Double(x as f64 - y as f64),
                            },
                            (Value::Double(x), Value::Double(y)) => Value::Double(x - y),
                            (Value::Smi(x), Value::Double(y)) => Value::Double(x as f64 - y),
                            (Value::Double(x), Value::Smi(y)) => Value::Double(x - y as f64),
                            _ => Value::Undefined,
                        };
                        stack.push(result);
                    }
                }
                crate::ir::IROpcode::Mul(_type_hint) => {
                    if stack.len() >= 2 {
                        let b = stack.pop().unwrap();
                        let a = stack.pop().unwrap();
                        let result = match (a, b) {
                            (Value::Smi(x), Value::Smi(y)) => match x.checked_mul(y) {
                                Some(prod) => Value::Smi(prod),
                                None => Value::Double(x as f64 * y as f64),
                            },
                            (Value::Double(x), Value::Double(y)) => Value::Double(x * y),
                            (Value::Smi(x), Value::Double(y)) => Value::Double(x as f64 * y),
                            (Value::Double(x), Value::Smi(y)) => Value::Double(x * y as f64),
                            _ => Value::Undefined,
                        };
                        stack.push(result);
                    }
                }
                crate::ir::IROpcode::Return => {
                    return Ok(stack.pop().unwrap_or(Value::Undefined));
                }
                // For other opcodes, we'll just skip them for now
                _ => {}
            }
        }

        Ok(stack.pop().unwrap_or(Value::Undefined))
    }

    /// Get the original bytecode
    pub fn bytecode(&self) -> &BytecodeChunk {
        &self.original_bytecode
    }

    /// Get the compilation tier
    pub fn tier(&self) -> CompilationTier {
        self.tier
    }

    /// Add an OSR entry point
    pub fn add_osr_entry(&mut self, entry: OSREntry) {
        self.osr_entries.push(entry);
    }

    /// Find OSR entry for given bytecode offset
    pub fn find_osr_entry(&self, bytecode_offset: usize) -> Option<&OSREntry> {
        self.osr_entries
            .iter()
            .find(|e| e.bytecode_offset == bytecode_offset)
    }

    /// Get the IR function
    pub fn ir(&self) -> &IRFunction {
        &self.ir
    }
}

// Note: We implement PartialEq manually because raw pointers don't auto-derive it
impl PartialEq for CompiledCode {
    fn eq(&self, other: &Self) -> bool {
        self.code == other.code
            && self.size == other.size
            && self.osr_entries == other.osr_entries
            && self.tier == other.tier
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytecode_system::Opcode;

    #[test]
    fn test_compiled_code_creation() {
        let mut chunk = BytecodeChunk::new();
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let code = CompiledCode::new(chunk, ir, CompilationTier::Baseline);

        assert!(!code.code.is_null());
        assert_eq!(code.size, 64);
        assert!(!code.entry_point.is_null());
        assert!(code.osr_entries.is_empty());
        assert_eq!(code.tier(), CompilationTier::Baseline);
    }

    #[test]
    fn test_compiled_code_execute_load_constant() {
        let mut chunk = BytecodeChunk::new();
        let idx = chunk.add_constant(bytecode_system::Value::Number(42.0));
        chunk.emit(Opcode::LoadConstant(idx));
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let code = CompiledCode::new(chunk, ir, CompilationTier::Baseline);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_compiled_code_execute_add() {
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(bytecode_system::Value::Number(10.0));
        let idx2 = chunk.add_constant(bytecode_system::Value::Number(32.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Add);
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let code = CompiledCode::new(chunk, ir, CompilationTier::Baseline);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_compiled_code_add_osr_entry() {
        let mut chunk = BytecodeChunk::new();
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let mut code = CompiledCode::new(chunk, ir, CompilationTier::Baseline);

        let entry = OSREntry::new(0, 0);
        code.add_osr_entry(entry);

        assert_eq!(code.osr_entries.len(), 1);
    }

    #[test]
    fn test_compiled_code_find_osr_entry() {
        let mut chunk = BytecodeChunk::new();
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let mut code = CompiledCode::new(chunk, ir, CompilationTier::Baseline);

        code.add_osr_entry(OSREntry::new(0, 0));
        code.add_osr_entry(OSREntry::new(10, 100));

        let found = code.find_osr_entry(10);
        assert!(found.is_some());
        assert_eq!(found.unwrap().native_offset, 100);

        let not_found = code.find_osr_entry(5);
        assert!(not_found.is_none());
    }

    #[test]
    fn test_compiled_code_tier() {
        let chunk = BytecodeChunk::new();
        let ir = IRFunction::new();

        let baseline = CompiledCode::new(chunk.clone(), ir.clone(), CompilationTier::Baseline);
        assert_eq!(baseline.tier(), CompilationTier::Baseline);

        let optimized = CompiledCode::new(chunk, ir, CompilationTier::Optimized);
        assert_eq!(optimized.tier(), CompilationTier::Optimized);
    }

    #[test]
    fn test_compiled_code_bytecode_access() {
        let mut chunk = BytecodeChunk::new();
        chunk.emit(Opcode::LoadTrue);
        chunk.emit(Opcode::Return);

        let ir = IRFunction::from_bytecode(&chunk);
        let code = CompiledCode::new(chunk.clone(), ir, CompilationTier::Baseline);

        assert_eq!(code.bytecode().instruction_count(), 2);
    }
}
