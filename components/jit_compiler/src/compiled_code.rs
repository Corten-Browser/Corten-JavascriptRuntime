//! Compiled native code representation
//!
//! Contains executable code generated by JIT compilers along with
//! metadata for OSR and deoptimization.

use crate::osr::OSREntry;
use core_types::{JsError, Value};
use std::mem;

/// Type of JIT compilation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompilationTier {
    /// Baseline template-based JIT
    Baseline,
    /// Optimizing speculative JIT
    Optimized,
}

/// Executable compiled code
///
/// Represents native code generated by the JIT compiler.
/// The code pointer points to real executable native code compiled by Cranelift.
pub struct CompiledCode {
    /// Pointer to the generated native code
    code: *const u8,
    /// Size of the generated code in bytes
    size: usize,
    /// Entry point for execution
    entry_point: *const (),
    /// OSR entry points for tier transitions
    osr_entries: Vec<OSREntry>,
    /// Whether this code is valid (for deoptimization)
    valid: bool,
}

impl CompiledCode {
    /// Create new compiled code from native code pointer
    ///
    /// # Arguments
    /// * `code` - Pointer to executable native code
    /// * `size` - Size of the native code in bytes
    /// * `osr_entries` - OSR entry points for tier transitions
    pub fn new(code: *const u8, size: usize, osr_entries: Vec<OSREntry>) -> Self {
        Self {
            code,
            size,
            entry_point: code as *const (),
            osr_entries,
            valid: true,
        }
    }

    /// Execute the compiled native code
    ///
    /// # Safety
    /// The code pointer must point to valid executable memory generated by Cranelift.
    /// The generated function signature is expected to be `fn() -> f64`.
    ///
    /// # Returns
    /// * `Ok(Value)` - The result of executing the native code
    /// * `Err(JsError)` - If the code has been invalidated
    pub fn execute(&self) -> Result<Value, JsError> {
        if !self.valid {
            return Err(JsError {
                kind: core_types::ErrorKind::InternalError,
                message: "Attempting to execute invalidated code".to_string(),
                stack: vec![],
                source_position: None,
            });
        }

        // Safety: We trust that Cranelift generated valid x86-64 code
        // and that the function signature matches () -> f64
        unsafe {
            let func: fn() -> f64 = mem::transmute(self.entry_point);
            let result = func();

            // Convert f64 result to appropriate Value type
            if result.is_nan() {
                Ok(Value::Undefined)
            } else if result.fract() == 0.0
                && result >= i32::MIN as f64
                && result <= i32::MAX as f64
            {
                Ok(Value::Smi(result as i32))
            } else {
                Ok(Value::Double(result))
            }
        }
    }

    /// Invalidate this code (for deoptimization)
    ///
    /// Once invalidated, attempts to execute this code will return an error.
    /// This is used when speculative optimizations are found to be incorrect.
    pub fn invalidate(&mut self) {
        self.valid = false;
    }

    /// Check if code is still valid
    pub fn is_valid(&self) -> bool {
        self.valid
    }

    /// Get the code pointer
    pub fn code_ptr(&self) -> *const u8 {
        self.code
    }

    /// Get the size of the native code
    pub fn size(&self) -> usize {
        self.size
    }

    /// Get the entry point pointer
    pub fn entry_point(&self) -> *const () {
        self.entry_point
    }

    /// Get the OSR entries
    pub fn osr_entries(&self) -> &[OSREntry] {
        &self.osr_entries
    }

    /// Add an OSR entry point
    pub fn add_osr_entry(&mut self, entry: OSREntry) {
        self.osr_entries.push(entry);
    }

    /// Find OSR entry for given bytecode offset
    pub fn find_osr_entry(&self, bytecode_offset: usize) -> Option<&OSREntry> {
        self.osr_entries
            .iter()
            .find(|e| e.bytecode_offset == bytecode_offset)
    }
}

// Note: We implement PartialEq manually because raw pointers don't auto-derive it
impl PartialEq for CompiledCode {
    fn eq(&self, other: &Self) -> bool {
        self.code == other.code
            && self.size == other.size
            && self.osr_entries == other.osr_entries
            && self.valid == other.valid
    }
}

// Implement Clone manually for CompiledCode
impl Clone for CompiledCode {
    fn clone(&self) -> Self {
        Self {
            code: self.code,
            size: self.size,
            entry_point: self.entry_point,
            osr_entries: self.osr_entries.clone(),
            valid: self.valid,
        }
    }
}

// Implement Debug manually due to raw pointers
impl std::fmt::Debug for CompiledCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompiledCode")
            .field("code", &self.code)
            .field("size", &self.size)
            .field("entry_point", &self.entry_point)
            .field("osr_entries", &self.osr_entries)
            .field("valid", &self.valid)
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cranelift_backend::CraneliftBackend;
    use bytecode_system::{BytecodeChunk, Opcode, Value as BcValue};

    #[test]
    fn test_compiled_code_creation() {
        let code = CompiledCode::new(std::ptr::null(), 0, vec![]);

        assert!(code.code.is_null());
        assert_eq!(code.size(), 0);
        assert!(code.is_valid());
        assert!(code.osr_entries().is_empty());
    }

    #[test]
    fn test_compiled_code_invalidation() {
        let mut code = CompiledCode::new(std::ptr::null(), 0, vec![]);

        assert!(code.is_valid());
        code.invalidate();
        assert!(!code.is_valid());
    }

    #[test]
    fn test_execute_invalidated_code_returns_error() {
        let mut code = CompiledCode::new(std::ptr::null(), 0, vec![]);
        code.invalidate();

        let result = code.execute();
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .message
            .contains("invalidated"));
    }

    #[test]
    fn test_compiled_code_add_osr_entry() {
        let mut code = CompiledCode::new(std::ptr::null(), 0, vec![]);

        let entry = OSREntry::new(0, 0);
        code.add_osr_entry(entry);

        assert_eq!(code.osr_entries().len(), 1);
    }

    #[test]
    fn test_compiled_code_find_osr_entry() {
        let mut code = CompiledCode::new(std::ptr::null(), 0, vec![]);

        code.add_osr_entry(OSREntry::new(0, 0));
        code.add_osr_entry(OSREntry::new(10, 100));

        let found = code.find_osr_entry(10);
        assert!(found.is_some());
        assert_eq!(found.unwrap().native_offset, 100);

        let not_found = code.find_osr_entry(5);
        assert!(not_found.is_none());
    }

    #[test]
    fn test_execute_native_constant() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx = chunk.add_constant(BcValue::Number(42.0));
        chunk.emit(Opcode::LoadConstant(idx));
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_addition() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(10.0));
        let idx2 = chunk.add_constant(BcValue::Number(32.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Add);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_subtraction() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(100.0));
        let idx2 = chunk.add_constant(BcValue::Number(58.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Sub);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_multiplication() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(6.0));
        let idx2 = chunk.add_constant(BcValue::Number(7.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Mul);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_division() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(84.0));
        let idx2 = chunk.add_constant(BcValue::Number(2.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Div);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_complex_expression() {
        // Compute: (10 + 20) * 2 - 18 = 42
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(10.0));
        let idx2 = chunk.add_constant(BcValue::Number(20.0));
        let idx3 = chunk.add_constant(BcValue::Number(2.0));
        let idx4 = chunk.add_constant(BcValue::Number(18.0));

        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Add);
        chunk.emit(Opcode::LoadConstant(idx3));
        chunk.emit(Opcode::Mul);
        chunk.emit(Opcode::LoadConstant(idx4));
        chunk.emit(Opcode::Sub);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_execute_native_double_result() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx1 = chunk.add_constant(BcValue::Number(10.0));
        let idx2 = chunk.add_constant(BcValue::Number(3.0));
        chunk.emit(Opcode::LoadConstant(idx1));
        chunk.emit(Opcode::LoadConstant(idx2));
        chunk.emit(Opcode::Div);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        match result {
            Value::Double(val) => {
                assert!((val - 3.333333333333333).abs() < 1e-10);
            }
            _ => panic!("Expected Double value"),
        }
    }

    #[test]
    fn test_execute_native_negation() {
        let mut backend = CraneliftBackend::new().unwrap();
        let mut chunk = BytecodeChunk::new();
        let idx = chunk.add_constant(BcValue::Number(-42.0));
        chunk.emit(Opcode::LoadConstant(idx));
        chunk.emit(Opcode::Neg);
        chunk.emit(Opcode::Return);

        let compiled = backend.compile_function(&chunk).unwrap();
        let code = CompiledCode::new(compiled.code_ptr, compiled.code_size, vec![]);

        let result = code.execute().unwrap();
        assert_eq!(result, Value::Smi(42));
    }

    #[test]
    fn test_compiled_code_equality() {
        let code1 = CompiledCode::new(0x1000 as *const u8, 64, vec![]);
        let code2 = CompiledCode::new(0x1000 as *const u8, 64, vec![]);
        let code3 = CompiledCode::new(0x2000 as *const u8, 64, vec![]);

        assert_eq!(code1, code2);
        assert_ne!(code1, code3);
    }

    #[test]
    fn test_compiled_code_clone() {
        let original = CompiledCode::new(0x1000 as *const u8, 64, vec![OSREntry::new(0, 0)]);
        let cloned = original.clone();

        assert_eq!(original, cloned);
        assert_eq!(cloned.osr_entries().len(), 1);
    }
}
